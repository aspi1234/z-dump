
[{"content":"Welcome this is my writeup on the linux pe os labs given by Prof Guillerme I hope you will learn something new and have a great time reading it.\nA container version of this lab can be found on docker hub and the files on github\nI have organised the impersonation of each user in the following steps :\nReconnaissance Planning Exploitation Let\u0026rsquo;s do this !! I. Special SUID Permissions : jason # CONTEXT # What is a SUID Permission : Assume we have two users on a system user A and user B. user B has a command that user A needs to run to perform a certain task. instead of user A having to request either the password or presence of user B to run this command each time, user B can simply set the SUID bit on this command and anyone can run this command with the same privilegies of user B ( as user B).You can find detailled information about linux SUID on google or you can read my post on the topic here.\n1. Reconnaissance : Finding SUID Files # Our first step is to find any programs on the system that have this special SUID permission. It would be difficult to check every file manually, so let\u0026rsquo;s use a search tool called find.\nWe will ask find to search the entire filesystem (/) for files (-type f) that have the SUID permission bit set (-perm -4000).\n$ find / -perm -4000 2\u0026gt;/dev/null\nThe search gives us a few results, but two files look particularly interesting and non-standard:\nTo get more details about these files, like who owns them, we can enhance our find command by telling it to execute ls -l on every file it finds:\n$ find / -perm -4000 2\u0026gt;/dev/null -exec ls -l {} +\nThe output confirms what we need to know:\n/usr/bin/print_my_stuff is owned by the user laela. /usr/share/print_file is owned by the user jason. 2. Planning # Irrespectively of what each program does, We now know that, if we run /usr/share/print_file, the system will execute it with all of jason\u0026rsquo;s privileges. Likewise, running /usr/bin/print_my_stuff will grant it laela\u0026rsquo;s privileges.\nOur plan is simple:\nInvestigate what each of these programs does. Determine if we can use their functionality, combined with their elevated permissions, to read sensitive files belonging to their owners. 3. exploitation # a. /usr/bin/print_my_stuff # Running this program simply prints the contents of laela\u0026rsquo;s home directory. While it confirms the SUID permission is working, it doesn\u0026rsquo;t seem to offer any way to control it, so we can\u0026rsquo;t do much with it for now.\nb. /usr/share/print_file # This program is more promising. Its name, print_file, strongly suggests its purpose. Let\u0026rsquo;s test its behavior. If we run it with the name of a file as an argument, it might print that file\u0026rsquo;s contents to the screen.\nSince the program runs as jason, it should be able to read any file that jason can. Let\u0026rsquo;s try to use it to read secret.txt from jason\u0026rsquo;s home directory.\nSuccess! Because the print_file program is owned by jason and has the SUID permission set, the operating system granted our request to read the file using jason\u0026rsquo;s permissions. We were able to see the contents of his secret file, even though our own user would normally not have access.\nII. Path Abuse : laela # CONTEXT # Whenever you type a command like ls or cd into your terminal, how does the shell know where to find the program to execute? It doesn\u0026rsquo;t magically know that the ls program is located in the /usr/bin/ directory.\nInstead, it consults an environment variable called PATH.\nThe PATH is simply a list of directories, separated by colons (:), that the shell will search through whenever it\u0026rsquo;s asked to run a command. You can see this list yourself by running:\n$ echo $PATH The shell searches these directories in order, from left to right. The very first executable it finds with a matching name is the one it runs.\n1.Enumeration/Reconnaisance # From our previous investigation, we know about the SUID program /usr/bin/print_my_stuff, which is owned by laela. Let\u0026rsquo;s see if we can find any other files related to this program that might give us clues about how it works. We can use find again to search for all files on the system owned by laela.\n$ find / -user laela 2\u0026gt;/dev/null\nWe\u0026rsquo;ve found the source code for the program, located at /var/backup_files/print_my_stuff.c. This is a huge advantage, as we can now examine exactly what the program does. Let\u0026rsquo;s look at its contents.\nLooking at the code, two lines stand out:\nsetuid(geteuid());: This line confirms that the program is intended to run with the full permissions of its owner, laela. system(\u0026quot;tree /home/laela\u0026quot;);: This is the crucial line. The program executes the tree command to list the contents of laela\u0026rsquo;s home directory. 2. Planning # Our path to exploitation is now clear. When we run /usr/bin/print_my_stuff, the following will happen:\nThe program will start running with laela\u0026rsquo;s permissions because of its SUID bit. It will then try to execute the tree command. The shell will search for tree in the directories listed in our PATH variable. Our plan is to control which tree program gets executed. We will:\nCreate our own script and name it tree. This script won\u0026rsquo;t list files; instead, it will be designed to read laela\u0026rsquo;s secret file. Place this script in a location where we have write permissions, such as the /tmp directory. Modify our PATH variable to put /tmp at the very beginning of the list. This will cause the shell to find our fake tree before it finds the real one. 3. Eploitation # Let\u0026rsquo;s put the plan into action.\nFirst, create our malicious tree script. We want it to read laela\u0026rsquo;s secret file. The cat command is perfect for this. We will create a file at /tmp/tree with the following content:\n#!/bin/bash # /tmp/tree content cat /home/laela/secret.txt Second, make the script executable. The system won\u0026rsquo;t run the script if it doesn\u0026rsquo;t have the execute permission set. We\u0026rsquo;ll use chmod to give it the necessary permissions.\n$ chmod 777 /tmp/tree\nThird, prepend /tmp to our PATH. This is the most important step. By placing /tmp at the front, we ensure our malicious script is found first.\n$ PATH=/tmp:$PATH\nFinally, run the SUID program. When we execute print_my_stuff, it will inherit our modified PATH, find our script in /tmp, and run it with laela\u0026rsquo;s privileges.\n$ /usr/bin/print_my_stuff And just like that, instead of listing the files in laela\u0026rsquo;s directory, the program executes our script and prints the content of her secret file.\nIII. Using sudo with xxd direct read for user landis # CONTEXT # So far, we\u0026rsquo;ve seen how SUID permissions on specific programs can grant us the powers of another user for a single task. sudo (short for \u0026ldquo;superuser do\u0026rdquo;) operates on a similar principle but is far more powerful and configurable. More on sudo vs suid here.\nThe root user is the administrator of a Linux system and can do anything. The sudo command allows a system administrator to grant certain users the ability to run specific commands as if they were the root user.\nThis is managed through a configuration file located at /etc/sudoers. This file contains the rules that define which users can run which commands with sudo. When you run a command with sudo, the system checks this file to see if you are authorized. If you are, it executes your command with root\u0026rsquo;s privileges.\n1. Reconnaissance/Enumeration # How can we know what commands, if any, our current user is allowed to run with sudo? Thankfully, there\u0026rsquo;s a simple command for that. The -l (list) flag will tell us exactly what our privileges are.\n$ sudo -l\nLet\u0026rsquo;s run this and see what it says about our user.\nThe output tells us two crucial things:\n(root): We are allowed to run the command as the root user. /usr/bin/xxd: The specific command we are allowed to run as root is xxd. xxd is a command-line tool that creates a \u0026ldquo;hex dump\u0026rdquo; of a file. This means it takes any file as input and outputs its contents as a sequence of hexadecimal numbers.\n2. Planning # Our reconnaissance has given us a clear path forward. We have the ability to run the xxd command with the full, unrestricted power of the root user. Since root can read any file on the entire system, we can use xxd to look at files that are normally completely off-limits to us, including the secret files of other users.\nOur plan is to use our sudo rights to run xxd on landis\u0026rsquo;s secret file.\n3. Exploitation # Going through the gtfobins we see that we can read/write to any file with xxd if it can be called/used with the sudo command with the following command.\n$ sudo xxd \u0026quot;file name\u0026quot; | xxd -r\nLet\u0026rsquo;s try this on alan\u0026rsquo;s secret file :\nIV. Using sudo,xxd and john to crack alan password # CONTEXT # We\u0026rsquo;ve established that our sudo privilege with xxd allows us to read any file on the system.Let\u0026rsquo;s use this ability to read the /etc/shadow file as stated by the lab.\nOn modern Linux systems, passwords are not stored in plain text. For security reasons, the system takes a user\u0026rsquo;s password and runs it through a one-way cryptographic function to create a unique \u0026ldquo;fingerprint\u0026rdquo; called a hash. This process is irreversible; you can\u0026rsquo;t turn the hash back into the original password. These hashes are stored in a highly-protected file: /etc/shadow.While we can\u0026rsquo;t reverse the hashes, we can try to guess the password.\nPlanning # Our previous exploitation gives us a clear advantage. We can read the /etc/shadow file, which means we can get the password hash for any user on the system, including alan.\nOur plan will have four steps:\nUse our sudo xxd | xxd -r technique to read the contents of /etc/shadow. Save alan\u0026rsquo;s password hash into a new file that we can work with. Use a password cracking tool, John the Ripper, along with a common wordlist rockyou.txt, to find the original password. If you have kali Os available, both the rockyou.txt wordlist[2] and john the ripper are available by default on kali so no need to download 2. Exploitation # Step 1: Read the /etc/shadow file\nWe\u0026rsquo;ll use the same command as before, but this time we will redirect the output (\u0026gt;) into a file named shadow.txt in our current directory. This makes it much easier to work with.\n$ sudo xxd \u0026quot;/etc/shadow\u0026quot; | xxd -r \u0026gt; shadow.txt\nNow, if we look at the contents of shadow.txt (cat shadow.txt), we will see the password hashes for all users on the system.\nStep 2: Isolate alan\u0026rsquo;s Hash\nTo make the cracking process faster and cleaner, we can copy the line corresponding to alan\u0026rsquo;s account into a new file. Let\u0026rsquo;s call it alan_hash.txt. The file should contain only one line, which will look something like this:\nalan:$6$somerandomsalt$anotherlongstringofcharacters:18214:0:99999:7:::\nStep 3: Crack the Hash with John the Ripper\nNow we can unleash John the Ripper on this hash. We will point it to our wordlist and the file containing the hash.\n$ john --wordlist=/path/to/rockyou.txt --format=crypt alan_hash.txt\n--wordlist=...: This tells John which list of passwords to try. alan_hash.txt: This is the file containing the hash we want to crack. John will start guessing passwords. If it finds a match, it will print the cracked password to the screen. After a short time, it should reveal alan\u0026rsquo;s password to be grant.\nStep 4: Log In and Read the Secret\nWith the password in hand, the final step is simple. We can use the su command to log in as alan.\n$ su - alan (Enter the password grant when prompted)\nOnce we are logged in as alan, we have all of his permissions. We can now easily read his secret file.\n$ cat /home/alan/secret.txt\nWe have successfully used a file-read vulnerability to achieve a full account compromise.\nV. Abusing systemd to read jean secret\u0026rsquo;s message # CONTEXT # On most linux system after the kernel is done preparing the hardware devices and making them visible to the OS it give space to the a process orchestrator called systemd. Systemd is the program in charge of bringing the computer to usefull state based on the target levels it needs to reach. It does so by reading unit file for services under the /etc/systemd/system/ directory which contains sysadmin custom services.\n1. Reconnaissance/Enumeration # Our goal is to find a poorly configured systemd service that we can take advantage of. We\u0026rsquo;ll start by looking in the directory where custom services are stored. It\u0026rsquo;s often helpful to list the files by modification time (-lt) to see if anything has been added recently.\n$ ls -lt /etc/systemd/system\nA file named backup.service immediately stands out. This doesn\u0026rsquo;t look like a standard system service. Let\u0026rsquo;s examine its contents to understand what it does.\nSo, we have a service that runs a script as jean. The final and most important question is: can we modify that script? Let\u0026rsquo;s check its permissions.\n$ ls -l /usr/bin/backup.sh\nThis is the vulnerability. The permissions -rwxrwxrwx mean that any user on the system has full read, write, and execute permissions on this file. We can change its contents to whatever we want.\nc. Content of /etc/systemd/system/mutli-user.target.wants/backup.service # d. premissions and content of /usr/bin/backup.sh # 2. Planning # Here is what we know at this point :\nA service, backup.service, is configured to run automatically when the system starts. This service runs with the full permissions of the user jean. The service executes a script, /usr/bin/backup.sh, which we are allowed to modify. We will replace the contents of the backup.sh script with our own command. Instead of performing a backup, the script will copy jean\u0026rsquo;s secret file into a public directory like /tmp, where we can easily read it.\n3. Exploitation # First, let\u0026rsquo;s modify the script. We will overwrite its contents with a simple copy command.\nNext, we need to trigger the service. The easiest way to trigger it is to simply restart the lab machine. When it boots back up, systemd will execute our modified script as the user jean.After the machine restarts, we can read the flag our script will have copied to the /tmp directory. All we have to do is view its contents.\n$ cat /tmp/jean_secret.txt VI Abusing pam module to impersonnate user giselle # CONTEXT # On a Linux system, many different programs need to authenticate users—login, su, ssh, the graphical lock screen, and so on. Instead of each program implementing its own authentication logic, they use a centralized and flexible framework called (PAM (Pluggable Authentication Modules))[https://docs.rockylinux.org/10/guides/security/pam/].These are set of security checkpoints that an application can use. An application like ssh can be configured to say, \u0026ldquo;For authentication, I need to check rule #1, then rule #2, then rule #3.\u0026rdquo; These rules are defined in configuration files located in the /etc/pam.d/ directory.Each rule in a PAM configuration file calls a specific \u0026ldquo;module\u0026rdquo; (a small library, like pam_unix.so) that performs a single task, such as checking the user\u0026rsquo;s password against /etc/shadow. By editing these configuration files, a system administrator can change the entire authentication process for a program without ever touching the program itself.\n1. Reconnaissance/Enumeration # Let\u0026rsquo;s start by exploring the /etc/pam.d/ directory to see if there are any unusual or recently modified files.\n$ ls -lt /etc/pam.d/\nA file named custom-rule stands out. This is not a standard system file. Let\u0026rsquo;s check its contents and, more importantly, its permissions.\n$ ls -l /etc/pam.d/custom-rule\n$ cat /etc/pam.d/custom-rule\nNow we need to find out which authentication process actually uses this file. We can search for any files in /etc/pam.d/ that include our custom-rule file using the grep command as follows.\n$ grep -r \u0026quot;custom-rule\u0026quot; /etc/pam.d/\nThe search points us to /etc/pam.d/common-auth.common-auth is a central file that contains authentication rules shared by many different services (login, su, etc.). Let\u0026rsquo;s look inside this file. $ cat /etc/pam.d/common-auth Content of /etc/pam.d/common-auth\nInside common-auth, we find two interesting lines, one after the other:\n1. auth [success=1 default=ignore] pam_succeed_if.so user != giselle 2. @include custom-rule Let\u0026rsquo;s break down what that first line does:\nauth: This rule applies to the authentication process. pam_succeed_if.so user != giselle: This module checks a condition. It \u0026ldquo;succeeds\u0026rdquo; if the user trying to authenticate is not giselle. It \u0026ldquo;fails\u0026rdquo; if the user is giselle. [success=1 default=ignore]: This is the control logic. success=1: If the module succeeds (the user is not giselle), then skip the next 1 rule. This means the @include custom-rule line will be completely ignored. default=ignore: If the module results in anything other than success (i.e., it fails because the user is giselle), then just ignore this outcome and continue to the next rule. In simple terms: The custom-rule file is only processed when the user trying to log in is giselle.\n2. Planning # We know that the contents of the custom-rule file are executed only when someone tries to authenticate as giselle. We have permission to write whatever we want into the custom-rule file. The plan is simple. We will add a new rule to the custom-rule file that will automatically grant authentication, no questions asked. There is a special PAM module perfect for this job called pam_permit.so. Its only purpose is to always return \u0026ldquo;success.\u0026rdquo;\n3. Exploitation # First, we will add our rule to the custom-rule file.\n$ echo 'auth sufficient pam_permit.so' \u0026gt; /etc/pam.d/custom-rule\nLet\u0026rsquo;s understand this rule:\nauth: It applies to authentication. pam_permit.so: This module always succeeds. sufficient: This control flag means that if this module succeeds (which it always does), PAM should consider the entire authentication process immediately successful and not bother checking any further rules (like the one that asks for a password). Now, let\u0026rsquo;s try to become giselle. We will use the su command.\n$ su - giselle\nHere is what happens :\nThe su command starts the PAM authentication process for the user giselle. PAM reads the common-auth file. The first rule (pam_succeed_if.so user != giselle) fails, because the user is giselle. The default=ignore logic tells PAM to simply move to the next rule. The next rule is @include custom-rule. PAM now reads our file. Our rule, auth sufficient pam_permit.so, is executed. The pam_permit.so module returns success. The sufficient flag tells PAM, \u0026ldquo;That\u0026rsquo;s good enough for me!\u0026rdquo; The authentication is declared a success, and the subsequent rules (including the one that would ask for giselle\u0026rsquo;s password) are never processed. Without asking for a password, the system grants us a shell as giselle. We have successfully bypassed the authentication process.\nWe have successfully impersonated all the user So what\u0026rsquo;s next ?? Let\u0026rsquo;s become root and tear everything apart !! shall we First run the following command\n$ echo \u0026#34;user ALL=(root) ALL\u0026#34; | xxd | sudo xxd -r - \u0026#34;/etc/sudoers.d/user\u0026#34; Log in as the root user and lmao\n$ sudo su root $ rm -rf / Do not run this on your host machine Gongrats !!\n","date":"25 October 2025","externalUrl":null,"permalink":"/writeups/linux-pe-os/","section":"Writeups","summary":"","title":"Linux Pe Os","type":"writeups"},{"content":"","date":"25 October 2025","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"","date":"25 October 2025","externalUrl":null,"permalink":"/","section":"z-dump","summary":"","title":"z-dump","type":"page"},{"content":"\n","date":"20 September 2025","externalUrl":null,"permalink":"/concepts/","section":"Concepts","summary":"","title":"Concepts","type":"concepts"},{"content":" A wall and a chalkboard: An Analogy to Understand Docker Images and Containers # Docker Image: The Permanent Wall # Think of a Docker Image as a finished, permanent \u0026ldquo;wall\u0026rdquo;.\nThis wall (image) is built from a stack of read-only layers, like transparent blocks stacked on each other.\nEach block contains a specific piece of the application, like its operating system or other software dependencies ( text editors, browsers, etc).\nBecause the wall is permanent and the blocks fused together, you cannot change any of its existing blocks.\nMany software providers, like Ubuntu, offer an official \u0026ldquo;foundation wall\u0026rdquo; (base images) version of their software that can be used to jumpstart a project.\nContainer: The Chalkboard on the Wall # A Container is a live instance of an image.\nIt’s what happens when you decide to use the wall.\nTo make it usable, Docker hangs a writable chalkboard over the the permanent wall. This chalkboard is a writable layer where all your changes, new files, and running processes happen.\nEvery container gets its own separate chalkboard, so what you do on one doesn\u0026rsquo;t affect another, even if they are mounted on the same wall.\nThe wall itself is never copied; containers simply reference the existing wall, making them fast and efficient to create.\nDockerfile: The Blueprint for the Wall # A Dockerfile is the builder\u0026rsquo;s blueprint. It’s a simple text file with step-by-step instructions on how to build a wall.\nEach instruction, like installing software or copying application code, tells the builder to add another permanent, read-only block (layer) to the stack.\nCustom Images: Customizing the Wall # Often, you don\u0026rsquo;t build a wall from the ground up.\nInstead, you create a Custom Image from an existing image. This involves taking an existing wall (like the official Ubuntu image) and giving the builder a blueprint that adds new, custom blocks on top.\nThink of it as adding a custom coat of paint or a detailed mural (your application code) on top of the existing structure. You\u0026rsquo;re creating a new, unique design without rebuilding the entire wall.\nThe docker build Command # This is the command you give to the builder.\nIt reads your Dockerfile blueprint,\ngathers any necessary local files (the \u0026ldquo;build context\u0026rdquo;)\nand constructs your final wall (your custom image) exactly as you specified\nThe docker run Command: Putting It All Together # The docker run command is the action that mounts a fresh chalkboard onto a specified wall.\nThis combination—the permanent wall (your image) plus the temporary chalkboard on top (the writable layer)—is what we call a Container.\nYou can write, draw, and erase on the chalkboard all you want without ever leaving a mark on the underlying wall.\nWhen you are done, you can either wipe the chalkboard clean and remove it, or leave it stopped on the wall to inspect later. You can mount hundreds of separate chalkboards on the very same wall, and each will be a unique, isolated container.\nBut remember, each of these containers occupies disk space, so remember to clean them up.\nThanks for reading. Until next Time, cheese :)\nThis post is a result of the frustration I got when I needed to create a 2gb Linux VM to clear some doubts I had regarding permissions on Linux (turns out this resulted in another post 1).\nA post on Linux permissions\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"20 September 2025","externalUrl":null,"permalink":"/concepts/docker-images-vs-containers/","section":"Concepts","summary":"","title":"You genuinely understand Docker images and containers if you have already used a chalk [white] board","type":"concepts"},{"content":" Environment variables # An environment is a collection of dynamic, named values—called environment variables—that can affect the way running processes will behave on a computer.\nEvery single process has its own copy of this environment.\nSome of the most common environment variables include :\nUSER (or LOGNAME): the name of the user currently login. HOME: The absolute path to the USER home directory (e.g., /home/hacker). This is where the shell starts you off and where programs look for user-specific configuration files. PATH: Arguably the most important one. It\u0026rsquo;s a colon-separated list of directories. When you type a command like cat without specifying its full path (/bin/cat), the shell searches through the directories listed in PATH until it finds an executable file with that name. PWD: The path to your Present Working Directory. It changes every time you cd. LANG: Controls the language, character set, and formatting for things like dates and currency. How to View and Work with environment variables # To see all environment variables: 1$ env 2# or 3$ printenv To see the value of a single variable: Use echo and a $ followed by the variable name. Note: There is no space between the $ sign and the variable name 1#echo $VAR_NAME 2$ echo $PATH # Output: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin Inheritance # When a new process is created, it inherits a copy of its parent\u0026rsquo;s environment 1.\nThis is why everything works so seamlessly accross different commands and programs.\nYou log in, and your main shell process (bash) is created with a full environment (USER=john, PATH=..., etc. ). You run the ls command. The shell creates a new child process for ls. This ls process gets a complete copy of the shell\u0026rsquo;s environment variables. The ls program can now look at its own environment to get information if it needs to, without having to ask the parent shell. Using the env Command # So, if every process automatically inherits the environment, why do we need a command called env?\nThe env command has two main purposes:\nTo view the current environment (when run with no arguments). To run a command in a modified environment, without changing your current shell\u0026rsquo;s environment. Running commands in a modified environment\nLet\u0026rsquo;s say your LANG environment variable responsible for your language preference is English, and you want to see the date in French without changing your system language for example.\n1# This will use our default English environment 2 3$ date 4 5# Output: Tue 21 Aug 2025 10:30:00 AM UTC 6 7# This runs \u0026#39;date\u0026#39; in a temporary, modified environment 8 9$ env LANG=fr_FR.UTF-8 date 10 11# Output: mar. 21 août 2025 10:30:00 UTC That is it. Thanks for reading\nI hope you learned something from this post. Any suggestions or areas of improvement? Please let me know, it will help me a lot to write better future posts. Thanks !!\nThis can be abused if the env command has a root setuid bit set. The following youtube playlist from Indronil Banerjee has a good playlist explaining how processes work on a linux Os.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"24 August 2025","externalUrl":null,"permalink":"/concepts/env/","section":"Concepts","summary":"","title":"env the Command Launcher you Never Knew you Had","type":"concepts"},{"content":" At its core, the locale command gives information on how a Linux system and its programs are configured to display information related to language and geographical region1.This is somehow similar to the \u0026ldquo;Language \u0026amp; Region\u0026rdquo; settings panel in Windows or macOS. It\u0026rsquo;s where you set things such as :\nThe display language (English, French, Japanese etc\u0026hellip;). The format for dates and times (MM/DD/YYYY vs. DD.MM.YYYY). The symbol for currency ($ vs. €). The character used as a decimal point (. vs. ,). How text should be sorted alphabetically. The locale command is the command-line equivalent of that settings panel. It shows the current values for all these settings in a given terminal session.\nHow to Use It # 1. Running locale without arguments # When you run the locale command with no arguments, it prints a list of environment variables that control these settings. Each variable handles a specific category.\n$ locale Example Output and What It Means:\nLANG=en_US.UTF-8: This is the most important one. It\u0026rsquo;s the default language and region for all categories unless a more specific variable is set. This means US English using the UTF-8 character set. LC_CTYPE=\u0026quot;en_US.UTF-8\u0026quot;: Controls character classification. (What is a letter? What is a number? How are they sorted?) LC_NUMERIC=\u0026quot;en_US.UTF-8\u0026quot;: Controls number formatting. (e.g., 1,000.00) LC_TIME=\u0026quot;en_US.UTF-8\u0026quot;: Controls date and time formatting. (e.g., Tuesday, August 21, 2025) LC_COLLATE=\u0026quot;en_US.UTF-8\u0026quot;: Controls the alphabetical sorting order of strings. LC_MONETARY=\u0026quot;en_US.UTF-8\u0026quot;: Controls currency formatting. (e.g., $1,234.56) LC_MESSAGES=\u0026quot;en_US.UTF-8\u0026quot;: Controls the language of system messages and program menus. LC_ALL=: This one is special. If it\u0026rsquo;s set, it acts as a master override and forces all categories to use its value, ignoring LANG and all other LC_* variables. It\u0026rsquo;s usually empty by default. 2. Listing All Available Locales: locale -a # It\u0026rsquo;s used to list all the \u0026ldquo;language packs\u0026rdquo; or locale definitions that are installed on the system.\n$ locale -a A program can only switch to a locale if that locale\u0026rsquo;s name appears in the output of locale -a.\nManaging Locales # Locales, are often not pre-installed to save space. The process involves generating the locale files from a master list. This is a system administration task and requires sudo.\nVerify Installed Locales # Using the locale -a command we can verify if the locale (language) we want to use hasn\u0026rsquo;t been installed (compile) already.\n$ locale -a This command reads the compiled locale files from the system. If it\u0026rsquo;s not in this list, the system can\u0026rsquo;t use it.\nInstalling New Locales (Requires sudo2) # This is a three-step process: edit, generate, and update. Note: Each of these steps requires root privileges. So you will need sudo to perform each step. Step 1: Edit the Master List The list of all possible locales your system knows about is in the file /etc/locale.gen.\n$ sudo nano /etc/locale.gen Inside, you will see hundreds of lines, most of them commented out with a #. Below is short output of the /etc/locale.gen file\n# ... #es_US.UTF-8 UTF-8 #eu_ES.UTF-8 UTF-8 #fa_IR UTF-8 #fi_FI.UTF-8 UTF-8 #fr_BE.UTF-8 UTF-8 #fr_CA.UTF-8 UTF-8 #fr_CH.UTF-8 UTF-8 #fr_FR.UTF-8 UTF-8 #fr_LU.UTF-8 UTF-8 # ... Step 2: Uncomment the Locales You Want Find the line for the locale you want to install (e.g., fr_FR.UTF-8 UTF-8) and remove the # at the beginning of the line. You can uncomment multiple locales if you wish. Save and close the file.\nStep 3: Generate the Locales (update) Now, run the locale-gen command. This command reads /etc/locale.gen, sees the lines you\u0026rsquo;ve uncommented, and compiles the necessary binary locale files from the system\u0026rsquo;s source data.\n$ sudo locale-gen You will see output as it generates the new files: Generating locales (this might take a while)... fr_FR.UTF-8... done Generation complete. Verify the Installation Run the verification command again. Your newly generated locale should now appear in the list.\n$ locale -a You can further test this using the env3 command as follow\n$ env LANG=fr_FR.UTF-8 date # replace the *value* of `LANG` with the value of the \u0026#34;language pack\u0026#34; you just compiled. Thanks for reading. Until then\nLanguage and geographical region informations refer to any output that is language dependent it won\u0026rsquo;t change output messages for commands that are not region dependent.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNot so sure what sudo is ?? check my post on sudo\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA post on env\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"24 August 2025","externalUrl":null,"permalink":"/concepts/locale/","section":"Concepts","summary":"","title":"Linux locale command","type":"concepts"},{"content":" New article ! I Was Wrong About sudo. Let\u0026rsquo;s Talk about SetUID # I thought I had a decent handle on Linux permissions users, groups, the classic rwx bits. Then I came across the pwn.college program misuse module. While working on a privilege escalation problem, something worked that just shouldn\u0026rsquo;t have, based on the mental model I was using at the time. It forced me to see that my whole idea of sudo was wrong. I always saw sudo as some magic keyword built into the OS. Well turns out it\u0026rsquo;s not. The real power is a much simpler, older concept called SetUID.SetUID is basically all you need to understand how this stuff really works.\nTL;DR # sudo is just a program that uses setuid: It isn\u0026rsquo;t a magic OS keyword. It\u0026rsquo;s a normal program owned by root that has the setuid permission bit. It uses its own setuid-given power to run your commands as root.\nsetuid is automatic privilege elevation: The setuid bit (the s in ls -l) on any program simply means: \u0026ldquo;Run this as the file\u0026rsquo;s owner, not the person who executed it.\u0026rdquo; No sudo command needed. If root owns the file, the program runs as root.\nYour \u0026ldquo;Effective\u0026rdquo; ID changes, not your \u0026ldquo;Real\u0026rdquo; one: The kernel tracks who you really are (Real UID) versus what you can currently do (Effective UID). setuid only changes your Effective UID for that one process, and that\u0026rsquo;s the ID the OS checks for file permissions.\nThis power is persistent (and dangerous): The elevated privilege lasts for the entire time the program is running. It doesn\u0026rsquo;t just turn off automatically, which is why poorly written setuid programs can be a huge security risk.\nNote : For security, most Linux systems mount temporary directories like /tmp with the nosuid mount option. This rule tells the kernel to completely ignore the SetUID bit for any program on that entire filesystem. It\u0026rsquo;s a security control to stop an attacker from running SetUID from this location. You can check this yourself by running mount | grep /tmp.\nBack to the Basics: How do processes normally get Permissions # On Linux, everything is about access control. The OS checks user and group IDs (UID and GID) to decide who can do what. When a program runs, it\u0026rsquo;s just a set of instructions spawning various processes, and that process needs permissions to do its job (like read a file or open a network connection).\nHere\u0026rsquo;s the normal rule: Every process inherits the user and group ID of the parent process that spawned it. When, user john, runs a command, it runs with john\u0026rsquo;s UID and GID.\nPrivilege Escalation is a FEATURE not a de facto vulnerability as I was thinking # This is where my first big \u0026ldquo;aha!\u0026rdquo; moment happened. Privilege Escalation (PE) isn\u0026rsquo;t inherently a vulnerability. At its core, it\u0026rsquo;s a mechanism that allows a user to perform actions that only a different user has the permissions for. It only becomes a vulnerability when it is misconfigured.\nOn Linux, this mechanism is primarily implemented through two tools we often see: SetUID and sudo. And as you will soon learn, the latter is completely dependent on the former.\nSetUID # SetUID (Set User ID) is a special permission bit. It has an octal value of 4 and is represented by an s in the file owner\u0026rsquo;s permission block (-rwsr-xr-x).\nIts function is simple but powerful: it allows anyone with execute permissions on the file to run that program with the power(permissions) of the file\u0026rsquo;s owner.\nHere’s how the process works step-by-step:\nA user starts a program that has the SetUID bit set. When the Linux kernel sees the s bit, it breaks the normal inheritance rule. Instead of using the user\u0026rsquo;s ID, the kernel sets the process\u0026rsquo;s effective user ID (euid) to the ID of the user who owns the file. If not explicitly changed in the code, the program continues to run with the owner\u0026rsquo;s privileges until it terminates. So, What Is sudo Then ? # sudo is not a magic do everything command it is just a normal C program located at /usr/bin/sudo that is owned by root and has the SetUID bit set.\nIts behavior is an exact, but much more secure, implementation of the SetUID mechanism. Here is what really happens when you type sudo apt update:\nYou execute /usr/bin/sudo, which starts up with an effective user ID of root because of the SetUID bit. But sudo doesn\u0026rsquo;t just run your command. It\u0026rsquo;s a security mechanism put in place to control and keep track of command running with high privilegies. First, it uses its root power to read the /etc/sudoers file—a file only root can read. It checks if you, the real user, is listed in that file and have permission to run apt update. If the rules match, it may ask for your password to verify your identity. Only if all these checks pass does sudo then spawn a child process to run apt update, which now inherits the root context from its parent, sudo. DIY # Not being a system programmer I asked gemini for a modified version of the cat command that prints the ruid,euid,gid and egid of the person runing the program along with the content of the file.\nCopy the code below into a file, for example: simplecat.c 1```c 2#include \u0026lt;stdio.h\u0026gt; 3#include \u0026lt;stdlib.h\u0026gt; 4#include \u0026lt;string.h\u0026gt; 5#include \u0026lt;sys/types.h\u0026gt; 6#include \u0026lt;unistd.h\u0026gt; // For getuid() and geteuid() 7 8int main(int argc, char *argv[]) { 9 FILE *fp; 10 char buffer[1024]; 11 12 // Print Real and Effective UIDs to observe the change 13 printf(\u0026#34;Real UID: %d\\n\u0026#34;, getuid()); 14 printf(\u0026#34;Effective UID: %d\\n\u0026#34;, geteuid()); 15 printf(\u0026#34;Real GID: %d\\n\u0026#34;, getgid()); 16 printf(\u0026#34;Effective GID: %d\\n\u0026#34;, getegid()); 17 18 if (argc \u0026lt; 2) { 19 fprintf(stderr, \u0026#34;Usage: %s \u0026lt;filename\u0026gt;\\n\u0026#34;, argv[0]); 20 return 1; 21 } 22 23 fp = fopen(argv[1], \u0026#34;r\u0026#34;); 24 if (fp == NULL) { 25 perror(\u0026#34;Error opening file\u0026#34;); 26 return 1; 27 } 28 29 while (fgets(buffer, sizeof(buffer), fp) != NULL) { 30 printf(\u0026#34;%s\u0026#34;, buffer); 31 } 32 33 fclose(fp); 34 return 0; 35} 36``` compile the program\ngcc simplecat.c -o mycat\nYou can try this by compiling two versions of this program and set the setuid bit for one and the other one without the setuid bit. The latter will be run using sudo to access. Create two distinct users with different permissions and try to access a file based on the permissions you have set, and note the behaviour when using either the sudo mycat command or the permission from the setuid bit\nNote : For security, most Linux distributions mount temporary directories like /tmp with the nosuid mount option. This rule tells the kernel to completely ignore the SetUID bit for any program on that entire filesystem. It\u0026rsquo;s a security control to stop an attacker from running SetUID from this location. You can check this yourself by running mount | grep /tmp.\nThat is it. Thanks for reading\nI hope you learned something from this post. Any suggestions or areas of improvement? Please let me know, it will help me a lot to write better future posts. Thanks !!\nLinux File Permissions sudo getuid suid ","date":"29 July 2025","externalUrl":null,"permalink":"/concepts/sudo-vs-setuid/","section":"Concepts","summary":"","title":"I Was So Wrong About Sudo","type":"concepts"},{"content":"\u0026ldquo;Hi there, I’m Ngatchou. You could say I’m an Information Technology enthusiast, but really, I\u0026rsquo;m just incredibly curious about how things work.\nMy journey into IT started with a professional degree in Networking \u0026amp; Telecommunication. But my real education began once I got my hands on the hardware. Dealing with computers and network devices made me intensely curious. I didn\u0026rsquo;t just want to know how they worked; I wanted to know how to make them behave in unintended ways and, most importantly, how to secure them. That feeling—especially the challenge of outsmarting the technology—was a clear sign. I realized my place wasn\u0026rsquo;t just in telecommunication, but in cybersecurity. So, I decided to switch paths and am now studying cybersecurity at the Uba.\nAs I dove into cybersecurity, I quickly learned that so much of the digital world is built on Linux. That\u0026rsquo;s what sparked my interest in its ecosystem. I went on to earn the Linux Foundation IT Associate certification, and now I\u0026rsquo;m on the path to becoming a Linux System Administrator by preparing for the LFCS. Of course, theory is one thing, but practice is everything. I sharpen my cybersecurity skills by actively participating in CTFs and on platforms like Hack The Box and pwn.college.\nCybersecurity can be intense, so I find it\u0026rsquo;s important to have other interests to stay balanced. When I’m not in front of a screen, you\u0026rsquo;ll probably find me reading, writing down random thoughts, listening to music (especially old-timers), or watching a good documentary. Lately, my curiosity has also pulled me toward the rise of generative AI, and I\u0026rsquo;m exploring how LLMs and Machine Learning can be integrated with cybersecurity.\nBut my interests aren\u0026rsquo;t just digital. I\u0026rsquo;m also involved in car security. It\u0026rsquo;s a completely different kind of challenge, but I get a lot of satisfaction from helping people regain access to their vehicles by programming new keys.\nSo, that\u0026rsquo;s me in a nutshell. A cybersecurity student, a Linux enthusiast, and a lifelong learner. Thanks for stopping by to read my story.\u0026rdquo;\n","externalUrl":null,"permalink":"/about/","section":"z-dump","summary":"","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" ","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"\nEducation # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e Professional Master in Cybersecurity Estimated August 2026 University of Bamenda - Uba \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e Licence en Ingenierie des Telecommunication et Reseaux Mobiles 2024 Universite de Ngaoundere Institut Universitaire des Science et Technologie de Yaounde - IUSTY \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e Diplome de qualification professionnel en maintenance des Reseaux des system informatique 2023 Minstere de la Formation Professionnel - MINEFOP CITIS - POWERBACHE \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e Brevet de Technicien Superieure en Reseaux et Telecommunication 2021 Ministere de l\u0026#39;enseignement superieure du Cameroun- MINESUP ISTAG Certifications # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e Linux Foundation IT Associate 2022 Linux Foundation \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e Fundamentals of Open Source IT and Cloud Computing LFS200 2022 Linux Foundation \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\rCertified Cloud Security Professional 2024 Simplilearn Prompt Engineering for Everyone 2024 CodeSignal Training # Developement web - Niveau Debutant 2025 D-clic Online Aspiring Certified Junior Cybersecurity Associate - CJCA Fulltime HackTheBox - HTB Online \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e Cybersecurity Training Fulltime PwnCollege Online Languages # French - English French - Primary Language\nEnglish - Secondary Language ","externalUrl":null,"permalink":"/resume/","section":"z-dump","summary":"","title":"Resume","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]